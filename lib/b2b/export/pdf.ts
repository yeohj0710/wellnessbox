import "server-only";

import { promises as fs } from "fs";
import path from "path";
import { spawn } from "child_process";

function runCommand(command: string, args: string[], timeoutMs: number) {
  return new Promise<{ code: number | null; stdout: string; stderr: string }>(
    (resolve, reject) => {
      const child = spawn(command, args, { stdio: ["ignore", "pipe", "pipe"] });
      const stdoutChunks: Buffer[] = [];
      const stderrChunks: Buffer[] = [];
      let finished = false;

      const done = (value: { code: number | null; stdout: string; stderr: string }) => {
        if (finished) return;
        finished = true;
        resolve(value);
      };

      const timer = setTimeout(() => {
        if (finished) return;
        finished = true;
        child.kill("SIGKILL");
        reject(new Error(`${command} timed out after ${timeoutMs}ms`));
      }, timeoutMs);

      child.stdout.on("data", (chunk: Buffer) => stdoutChunks.push(chunk));
      child.stderr.on("data", (chunk: Buffer) => stderrChunks.push(chunk));
      child.on("error", (error) => {
        clearTimeout(timer);
        reject(error);
      });
      child.on("close", (code) => {
        clearTimeout(timer);
        done({
          code,
          stdout: Buffer.concat(stdoutChunks).toString("utf8"),
          stderr: Buffer.concat(stderrChunks).toString("utf8"),
        });
      });
    }
  );
}

export async function convertPptxBufferToPdf(input: {
  pptxBuffer: Buffer;
  filename: string;
}) {
  const tempDir = path.join(process.cwd(), "tmp", `b2b-export-${Date.now()}-${Math.random().toString(16).slice(2, 8)}`);
  await fs.mkdir(tempDir, { recursive: true });

  const pptxPath = path.join(tempDir, input.filename);
  await fs.writeFile(pptxPath, input.pptxBuffer);

  const sofficeCommand = process.env.SOFFICE_BIN || "soffice";
  const convertArgs = [
    "--headless",
    "--convert-to",
    "pdf",
    "--outdir",
    tempDir,
    pptxPath,
  ];

  try {
    const result = await runCommand(sofficeCommand, convertArgs, 60_000);
    if (result.code !== 0) {
      return {
        ok: false as const,
        reason: `soffice failed with code ${result.code}`,
        stderr: result.stderr,
      };
    }

    const pdfFilename = input.filename.replace(/\.pptx$/i, ".pdf");
    const pdfPath = path.join(tempDir, pdfFilename);
    const exists = await fs
      .access(pdfPath)
      .then(() => true)
      .catch(() => false);
    if (!exists) {
      return {
        ok: false as const,
        reason: "PDF file was not generated by soffice",
      };
    }

    const pdfBuffer = await fs.readFile(pdfPath);
    return { ok: true as const, pdfBuffer };
  } catch (error) {
    return {
      ok: false as const,
      reason: error instanceof Error ? error.message : "PDF conversion failed",
    };
  } finally {
    await fs.rm(tempDir, { recursive: true, force: true }).catch(() => undefined);
  }
}
