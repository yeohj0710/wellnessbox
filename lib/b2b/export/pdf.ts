import "server-only";

import { promises as fs } from "fs";
import path from "path";
import { spawn } from "child_process";
import type { LayoutDocument } from "@/lib/b2b/export/layout-types";
import { buildLayoutHtml } from "@/lib/b2b/export/layout-html";

function runCommand(command: string, args: string[], timeoutMs: number) {
  return new Promise<{ code: number | null; stdout: string; stderr: string }>(
    (resolve, reject) => {
      const child = spawn(command, args, { stdio: ["ignore", "pipe", "pipe"] });
      const stdoutChunks: Buffer[] = [];
      const stderrChunks: Buffer[] = [];
      let finished = false;

      const done = (value: { code: number | null; stdout: string; stderr: string }) => {
        if (finished) return;
        finished = true;
        resolve(value);
      };

      const timer = setTimeout(() => {
        if (finished) return;
        finished = true;
        child.kill("SIGKILL");
        reject(new Error(`${command} timed out after ${timeoutMs}ms`));
      }, timeoutMs);

      child.stdout.on("data", (chunk: Buffer) => stdoutChunks.push(chunk));
      child.stderr.on("data", (chunk: Buffer) => stderrChunks.push(chunk));
      child.on("error", (error) => {
        clearTimeout(timer);
        reject(error);
      });
      child.on("close", (code) => {
        clearTimeout(timer);
        done({
          code,
          stdout: Buffer.concat(stdoutChunks).toString("utf8"),
          stderr: Buffer.concat(stderrChunks).toString("utf8"),
        });
      });
    }
  );
}

async function tryConvertBySoffice(input: {
  tempDir: string;
  filename: string;
  pptxBuffer: Buffer;
}) {
  const pptxPath = path.join(input.tempDir, input.filename);
  await fs.writeFile(pptxPath, input.pptxBuffer);

  const sofficeCommand = process.env.SOFFICE_BIN || "soffice";
  const convertArgs = [
    "--headless",
    "--convert-to",
    "pdf",
    "--outdir",
    input.tempDir,
    pptxPath,
  ];

  const result = await runCommand(sofficeCommand, convertArgs, 60_000);
  if (result.code !== 0) {
    return {
      ok: false as const,
      reason: `soffice failed with code ${result.code}`,
      stderr: result.stderr,
    };
  }

  const pdfFilename = input.filename.replace(/\.pptx$/i, ".pdf");
  const pdfPath = path.join(input.tempDir, pdfFilename);
  const exists = await fs
    .access(pdfPath)
    .then(() => true)
    .catch(() => false);
  if (!exists) {
    return {
      ok: false as const,
      reason: "PDF file was not generated by soffice",
    };
  }

  const pdfBuffer = await fs.readFile(pdfPath);
  return { ok: true as const, pdfBuffer };
}

function toErrorReason(error: unknown, fallback: string) {
  return error instanceof Error && error.message.trim().length > 0
    ? error.message
    : fallback;
}

async function loadPlaywrightModule() {
  try {
    const dynamicImport = new Function("moduleName", "return import(moduleName);") as (
      moduleName: string
    ) => Promise<any>;
    return await dynamicImport("playwright");
  } catch {
    return null;
  }
}

async function tryConvertByPlaywright(layout: LayoutDocument) {
  const playwright = await loadPlaywrightModule();
  if (!playwright?.chromium) {
    return {
      ok: false as const,
      reason: "Playwright is not available",
    };
  }

  const browser = await playwright.chromium.launch({ headless: true });
  try {
    const page = await browser.newPage();
    await page.setContent(buildLayoutHtml(layout), {
      waitUntil: "domcontentloaded",
    });
    const pdfBuffer = await page.pdf({
      format: "A4",
      printBackground: true,
      displayHeaderFooter: false,
      margin: {
        top: "0",
        right: "0",
        bottom: "0",
        left: "0",
      },
      preferCSSPageSize: true,
    });
    return {
      ok: true as const,
      pdfBuffer: Buffer.from(pdfBuffer),
    };
  } catch (error) {
    return {
      ok: false as const,
      reason: error instanceof Error ? error.message : "Playwright PDF conversion failed",
    };
  } finally {
    await browser.close();
  }
}

function allowSofficeFallback() {
  const value = (process.env.B2B_ALLOW_PDF_SOFFICE_FALLBACK || "")
    .trim()
    .toLowerCase();
  return value === "1" || value === "true" || value === "y";
}

export async function convertPptxBufferToPdf(input: {
  pptxBuffer: Buffer;
  filename: string;
  layout?: LayoutDocument;
}) {
  const tempDir = path.join(
    process.cwd(),
    "tmp",
    `b2b-export-${Date.now()}-${Math.random().toString(16).slice(2, 8)}`
  );
  await fs.mkdir(tempDir, { recursive: true });

  try {
    if (input.layout) {
      const playwrightResult = await tryConvertByPlaywright(input.layout);
      if (playwrightResult.ok) {
        return {
          ok: true as const,
          pdfBuffer: playwrightResult.pdfBuffer,
          engine: "playwright" as const,
        };
      }

      if (!allowSofficeFallback()) {
        return {
          ok: false as const,
          reason: `${playwrightResult.reason}. Soffice fallback is disabled to keep web/PDF parity.`,
        };
      }

      let sofficeFallback:
        | { ok: true; pdfBuffer: Buffer }
        | { ok: false; reason: string; stderr?: string };
      try {
        sofficeFallback = await tryConvertBySoffice({
          tempDir,
          filename: input.filename,
          pptxBuffer: input.pptxBuffer,
        });
      } catch (error) {
        sofficeFallback = {
          ok: false,
          reason: toErrorReason(error, "soffice conversion failed"),
        };
      }

      if (sofficeFallback.ok) {
        return {
          ok: true as const,
          pdfBuffer: sofficeFallback.pdfBuffer,
          engine: "soffice" as const,
        };
      }

      return {
        ok: false as const,
        reason: `${playwrightResult.reason}; soffice=${sofficeFallback.reason}`,
      };
    }

    const sofficeOnly = await tryConvertBySoffice({
      tempDir,
      filename: input.filename,
      pptxBuffer: input.pptxBuffer,
    });
    if (sofficeOnly.ok) {
      return {
        ok: true as const,
        pdfBuffer: sofficeOnly.pdfBuffer,
        engine: "soffice" as const,
      };
    }
    return {
      ok: false as const,
      reason: sofficeOnly.reason,
    };
  } catch (error) {
    return {
      ok: false as const,
      reason: error instanceof Error ? error.message : "PDF conversion failed",
    };
  } finally {
    await fs.rm(tempDir, { recursive: true, force: true }).catch(() => undefined);
  }
}
