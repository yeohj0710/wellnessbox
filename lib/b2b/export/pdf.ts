import "server-only";

import { promises as fs } from "fs";
import path from "path";
import { spawn } from "child_process";
import type { LayoutDocument, LayoutNode } from "@/lib/b2b/export/layout-types";

const MM_TO_PX = 3.7795275591;

function runCommand(command: string, args: string[], timeoutMs: number) {
  return new Promise<{ code: number | null; stdout: string; stderr: string }>(
    (resolve, reject) => {
      const child = spawn(command, args, { stdio: ["ignore", "pipe", "pipe"] });
      const stdoutChunks: Buffer[] = [];
      const stderrChunks: Buffer[] = [];
      let finished = false;

      const done = (value: { code: number | null; stdout: string; stderr: string }) => {
        if (finished) return;
        finished = true;
        resolve(value);
      };

      const timer = setTimeout(() => {
        if (finished) return;
        finished = true;
        child.kill("SIGKILL");
        reject(new Error(`${command} timed out after ${timeoutMs}ms`));
      }, timeoutMs);

      child.stdout.on("data", (chunk: Buffer) => stdoutChunks.push(chunk));
      child.stderr.on("data", (chunk: Buffer) => stderrChunks.push(chunk));
      child.on("error", (error) => {
        clearTimeout(timer);
        reject(error);
      });
      child.on("close", (code) => {
        clearTimeout(timer);
        done({
          code,
          stdout: Buffer.concat(stdoutChunks).toString("utf8"),
          stderr: Buffer.concat(stderrChunks).toString("utf8"),
        });
      });
    }
  );
}

async function tryConvertBySoffice(input: {
  tempDir: string;
  filename: string;
  pptxBuffer: Buffer;
}) {
  const pptxPath = path.join(input.tempDir, input.filename);
  await fs.writeFile(pptxPath, input.pptxBuffer);

  const sofficeCommand = process.env.SOFFICE_BIN || "soffice";
  const convertArgs = [
    "--headless",
    "--convert-to",
    "pdf",
    "--outdir",
    input.tempDir,
    pptxPath,
  ];

  const result = await runCommand(sofficeCommand, convertArgs, 60_000);
  if (result.code !== 0) {
    return {
      ok: false as const,
      reason: `soffice failed with code ${result.code}`,
      stderr: result.stderr,
    };
  }

  const pdfFilename = input.filename.replace(/\.pptx$/i, ".pdf");
  const pdfPath = path.join(input.tempDir, pdfFilename);
  const exists = await fs
    .access(pdfPath)
    .then(() => true)
    .catch(() => false);
  if (!exists) {
    return {
      ok: false as const,
      reason: "PDF file was not generated by soffice",
    };
  }

  const pdfBuffer = await fs.readFile(pdfPath);
  return { ok: true as const, pdfBuffer };
}

function escapeHtml(value: string) {
  return value
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/\"/g, "&quot;");
}

function renderNodeHtml(node: LayoutNode) {
  const style = [
    "position:absolute",
    `left:${node.x * MM_TO_PX}px`,
    `top:${node.y * MM_TO_PX}px`,
    `width:${node.w * MM_TO_PX}px`,
    `height:${node.h * MM_TO_PX}px`,
    "box-sizing:border-box",
    "overflow:hidden",
  ];

  if (node.type === "rect") {
    style.push(`background:#${node.fill || "FFFFFF"}`);
    return `<div style="${style.join(";")}"></div>`;
  }

  style.push(`color:#${node.color || "111827"}`);
  style.push(`font-size:${node.fontSize ?? 12}px`);
  style.push(`font-weight:${node.bold ? 700 : 400}`);
  style.push("line-height:1.28");
  style.push("white-space:pre-wrap");
  style.push("word-break:keep-all");
  return `<div style="${style.join(";")}">${escapeHtml(node.text || "")}</div>`;
}

function buildLayoutHtml(layout: LayoutDocument) {
  const pages = layout.pages
    .map((page) => {
      const pageNodes = page.nodes.map((node) => renderNodeHtml(node)).join("");
      return `
        <section class="page" style="width:${page.widthMm * MM_TO_PX}px;height:${
          page.heightMm * MM_TO_PX
        }px;">
          ${pageNodes}
        </section>
      `;
    })
    .join("\n");

  return `<!doctype html>
  <html>
    <head>
      <meta charset="utf-8" />
      <style>
        html, body {
          margin: 0;
          padding: 0;
          background: #fff;
        }
        .page {
          position: relative;
          margin: 0 auto;
          page-break-after: always;
          break-after: page;
        }
        .page:last-child {
          page-break-after: auto;
          break-after: auto;
        }
      </style>
    </head>
    <body>${pages}</body>
  </html>`;
}

async function loadPlaywrightModule() {
  try {
    const dynamicImport = new Function("moduleName", "return import(moduleName);") as (
      moduleName: string
    ) => Promise<any>;
    return await dynamicImport("playwright");
  } catch {
    return null;
  }
}

async function tryConvertByPlaywright(layout: LayoutDocument) {
  const playwright = await loadPlaywrightModule();
  if (!playwright?.chromium) {
    return {
      ok: false as const,
      reason: "Playwright is not available",
    };
  }

  const browser = await playwright.chromium.launch({ headless: true });
  try {
    const page = await browser.newPage();
    await page.setContent(buildLayoutHtml(layout), {
      waitUntil: "domcontentloaded",
    });
    const pdfBuffer = await page.pdf({
      format: "A4",
      printBackground: true,
      displayHeaderFooter: false,
      margin: {
        top: "0",
        right: "0",
        bottom: "0",
        left: "0",
      },
      preferCSSPageSize: true,
    });
    return {
      ok: true as const,
      pdfBuffer: Buffer.from(pdfBuffer),
    };
  } catch (error) {
    return {
      ok: false as const,
      reason: error instanceof Error ? error.message : "Playwright PDF conversion failed",
    };
  } finally {
    await browser.close();
  }
}

export async function convertPptxBufferToPdf(input: {
  pptxBuffer: Buffer;
  filename: string;
  layout?: LayoutDocument;
}) {
  const tempDir = path.join(
    process.cwd(),
    "tmp",
    `b2b-export-${Date.now()}-${Math.random().toString(16).slice(2, 8)}`
  );
  await fs.mkdir(tempDir, { recursive: true });

  try {
    const sofficeResult = await tryConvertBySoffice({
      tempDir,
      filename: input.filename,
      pptxBuffer: input.pptxBuffer,
    });
    if (sofficeResult.ok) {
      return { ok: true as const, pdfBuffer: sofficeResult.pdfBuffer, engine: "soffice" as const };
    }

    if (!input.layout) {
      return {
        ok: false as const,
        reason: sofficeResult.reason,
      };
    }

    const playwrightResult = await tryConvertByPlaywright(input.layout);
    if (playwrightResult.ok) {
      return {
        ok: true as const,
        pdfBuffer: playwrightResult.pdfBuffer,
        engine: "playwright" as const,
      };
    }

    return {
      ok: false as const,
      reason: `${sofficeResult.reason}; playwright=${playwrightResult.reason}`,
    };
  } catch (error) {
    return {
      ok: false as const,
      reason: error instanceof Error ? error.message : "PDF conversion failed",
    };
  } finally {
    await fs.rm(tempDir, { recursive: true, force: true }).catch(() => undefined);
  }
}
