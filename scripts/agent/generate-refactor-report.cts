const fs = require("node:fs") as typeof import("node:fs");
const pathUtil = require("node:path") as typeof import("node:path");
const {
  countFileLines,
  listFilesRecursively,
  toPosixRelative,
} = require("../lib/code-file-scan.cts") as {
  countFileLines: (filePath: string) => number;
  listFilesRecursively: (
    rootDir: string,
    options?: {
      excludeDirs?: string[] | Set<string>;
      includeExtensions?: string[] | Set<string>;
      ignoreDotEntries?: boolean;
    }
  ) => string[];
  toPosixRelative: (rootDir: string, filePath: string) => string;
};

type Row = {
  file: string;
  lines: number;
};

const REPO_ROOT = process.cwd();
const OUTPUT_PATH = pathUtil.join(REPO_ROOT, "REFACTOR_HOTSPOTS.md");

function shouldInclude(rel: string) {
  if (rel.startsWith("docs/")) return false;
  if (rel.startsWith("prisma/migrations/")) return false;
  if (rel.startsWith("android/app/build/")) return false;
  if (rel.startsWith("ios/build/")) return false;
  if (rel.startsWith(".next/")) return false;
  if (rel.endsWith(".md")) return false;
  return (
    rel.endsWith(".ts") ||
    rel.endsWith(".tsx") ||
    rel.endsWith(".js") ||
    rel.endsWith(".jsx")
  );
}

function topRows(rows: Row[], size: number) {
  return [...rows]
    .sort((a, b) => b.lines - a.lines || a.file.localeCompare(b.file))
    .slice(0, size);
}

function topRowsByFilter(
  rows: Row[],
  size: number,
  predicate: (row: Row) => boolean
) {
  return topRows(rows.filter(predicate), size);
}

function isApiRouteFile(file: string) {
  return file.startsWith("app/api/") && file.endsWith("/route.ts");
}

function isFrontendSurfaceFile(file: string) {
  if (file.startsWith("app/api/")) return false;
  if (file.startsWith("app/")) return true;
  if (file.startsWith("components/")) return true;
  return false;
}

function section(title: string, rows: Row[]) {
  const lines: string[] = [];
  lines.push(`## ${title}`);
  lines.push("");
  lines.push("| Lines | File |");
  lines.push("|---:|---|");
  for (const row of rows) {
    lines.push(`| ${row.lines} | \`${row.file}\` |`);
  }
  lines.push("");
  return lines.join("\n");
}

function main() {
  const files = listFilesRecursively(REPO_ROOT, {
    excludeDirs: [".git", "node_modules", ".next"],
    ignoreDotEntries: true,
  })
    .map((filePath) => ({
      abs: filePath,
      rel: toPosixRelative(REPO_ROOT, filePath),
    }))
    .filter((item) => shouldInclude(item.rel));

  const runtimeRows: Row[] = [];
  const scriptRows: Row[] = [];

  for (const item of files) {
    const lines = countFileLines(item.abs);
    if (item.rel.startsWith("scripts/")) {
      scriptRows.push({ file: item.rel, lines });
      continue;
    }
    runtimeRows.push({ file: item.rel, lines });
  }

  const topRuntime = topRows(runtimeRows, 25);
  const topApiRoutes = topRowsByFilter(runtimeRows, 20, (row) =>
    isApiRouteFile(row.file)
  );
  const topFrontendSurfaces = topRowsByFilter(runtimeRows, 20, (row) =>
    isFrontendSurfaceFile(row.file)
  );
  const topScripts = topRows(scriptRows, 15);

  const doc: string[] = [];
  doc.push("# Refactor Hotspots");
  doc.push("");
  doc.push("Auto-generated by `scripts/agent/generate-refactor-report.cts`.");
  doc.push("Run `npm run agent:refactor-report` to refresh this report.");
  doc.push("");
  doc.push(section("Runtime Top 25", topRuntime));
  doc.push(section("API Route Top 20", topApiRoutes));
  doc.push(section("Frontend Surface Top 20", topFrontendSurfaces));
  doc.push(section("Scripts Top 15", topScripts));
  doc.push("## Notes");
  doc.push("");
  doc.push("- Refresh companion checks with `npm run audit:hotspots` after major changes.");
  doc.push("- Prefer splitting orchestration-heavy files before pure data/config files.");
  doc.push("- For UI files, extract presentational sections first, then hook logic.");
  doc.push("- Re-run after each major refactor to validate actual reduction.");
  doc.push("");

  const nextContent = doc.join("\n");
  const currentContent = fs.existsSync(OUTPUT_PATH)
    ? fs.readFileSync(OUTPUT_PATH, "utf8")
    : null;
  if (currentContent !== nextContent) {
    fs.writeFileSync(OUTPUT_PATH, nextContent, "utf8");
    console.log(`Wrote hotspot report: ${toPosixRelative(REPO_ROOT, OUTPUT_PATH)}`);
  } else {
    console.log(`Hotspot report unchanged: ${toPosixRelative(REPO_ROOT, OUTPUT_PATH)}`);
  }
}

main();
