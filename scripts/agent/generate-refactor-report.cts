const fs = require("node:fs") as typeof import("node:fs");
const pathUtil = require("node:path") as typeof import("node:path");

type Row = {
  file: string;
  lines: number;
};

const REPO_ROOT = process.cwd();
const OUTPUT_PATH = pathUtil.join(REPO_ROOT, "REFACTOR_HOTSPOTS.md");

function listFiles(dir: string): string[] {
  const out: string[] = [];
  const entries = fs.readdirSync(dir, { withFileTypes: true });

  for (const entry of entries) {
    if (entry.name === ".git" || entry.name === "node_modules" || entry.name === ".next") {
      continue;
    }
    const fullPath = pathUtil.join(dir, entry.name);
    if (entry.isDirectory()) {
      out.push(...listFiles(fullPath));
      continue;
    }
    if (!entry.isFile()) continue;
    out.push(fullPath);
  }

  return out;
}

function shouldInclude(rel: string) {
  if (rel.startsWith("docs/")) return false;
  if (rel.startsWith("prisma/migrations/")) return false;
  if (rel.startsWith("android/app/build/")) return false;
  if (rel.startsWith("ios/build/")) return false;
  if (rel.startsWith(".next/")) return false;
  if (rel.endsWith(".md")) return false;
  return (
    rel.endsWith(".ts") ||
    rel.endsWith(".tsx") ||
    rel.endsWith(".js") ||
    rel.endsWith(".jsx")
  );
}

function countLines(filePath: string) {
  const raw = fs.readFileSync(filePath, "utf8");
  if (!raw) return 0;
  return raw.split(/\r?\n/).length;
}

function toRel(filePath: string) {
  return pathUtil.relative(REPO_ROOT, filePath).replace(/\\/g, "/");
}

function topRows(rows: Row[], size: number) {
  return [...rows].sort((a, b) => b.lines - a.lines).slice(0, size);
}

function section(title: string, rows: Row[]) {
  const lines: string[] = [];
  lines.push(`## ${title}`);
  lines.push("");
  lines.push("| Lines | File |");
  lines.push("|---:|---|");
  for (const row of rows) {
    lines.push(`| ${row.lines} | \`${row.file}\` |`);
  }
  lines.push("");
  return lines.join("\n");
}

function main() {
  const files = listFiles(REPO_ROOT)
    .map((filePath) => ({
      abs: filePath,
      rel: toRel(filePath),
    }))
    .filter((item) => shouldInclude(item.rel));

  const runtimeRows: Row[] = [];
  const scriptRows: Row[] = [];

  for (const item of files) {
    const lines = countLines(item.abs);
    if (item.rel.startsWith("scripts/")) {
      scriptRows.push({ file: item.rel, lines });
      continue;
    }
    runtimeRows.push({ file: item.rel, lines });
  }

  const topRuntime = topRows(runtimeRows, 25);
  const topScripts = topRows(scriptRows, 15);

  const doc: string[] = [];
  doc.push("# Refactor Hotspots");
  doc.push("");
  doc.push("Auto-generated by `scripts/agent/generate-refactor-report.cts`.");
  doc.push(`Generated at: ${new Date().toISOString()}`);
  doc.push("");
  doc.push(section("Runtime Top 25", topRuntime));
  doc.push(section("Scripts Top 15", topScripts));
  doc.push("## Notes");
  doc.push("");
  doc.push("- Prefer splitting orchestration-heavy files before pure data/config files.");
  doc.push("- For UI files, extract presentational sections first, then hook logic.");
  doc.push("- Re-run after each major refactor to validate actual reduction.");
  doc.push("");

  fs.writeFileSync(OUTPUT_PATH, doc.join("\n"), "utf8");
  console.log(`Wrote hotspot report: ${toRel(OUTPUT_PATH)}`);
}

main();
