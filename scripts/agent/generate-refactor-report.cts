const fs = require("node:fs") as typeof import("node:fs");
const pathUtil = require("node:path") as typeof import("node:path");

type Row = {
  file: string;
  lines: number;
};

const REPO_ROOT = process.cwd();
const OUTPUT_PATH = pathUtil.join(REPO_ROOT, "REFACTOR_HOTSPOTS.md");

function listFiles(dir: string): string[] {
  const out: string[] = [];
  const entries = fs
    .readdirSync(dir, { withFileTypes: true })
    .sort((a, b) => a.name.localeCompare(b.name));

  for (const entry of entries) {
    if (entry.name === ".git" || entry.name === "node_modules" || entry.name === ".next") {
      continue;
    }
    const fullPath = pathUtil.join(dir, entry.name);
    if (entry.isDirectory()) {
      out.push(...listFiles(fullPath));
      continue;
    }
    if (!entry.isFile()) continue;
    out.push(fullPath);
  }

  return out;
}

function shouldInclude(rel: string) {
  if (rel.startsWith("docs/")) return false;
  if (rel.startsWith("prisma/migrations/")) return false;
  if (rel.startsWith("android/app/build/")) return false;
  if (rel.startsWith("ios/build/")) return false;
  if (rel.startsWith(".next/")) return false;
  if (rel.endsWith(".md")) return false;
  return (
    rel.endsWith(".ts") ||
    rel.endsWith(".tsx") ||
    rel.endsWith(".js") ||
    rel.endsWith(".jsx")
  );
}

function countLines(filePath: string) {
  const raw = fs.readFileSync(filePath, "utf8");
  if (!raw) return 0;
  return raw.split(/\r?\n/).length;
}

function toRel(filePath: string) {
  return pathUtil.relative(REPO_ROOT, filePath).replace(/\\/g, "/");
}

function topRows(rows: Row[], size: number) {
  return [...rows]
    .sort((a, b) => b.lines - a.lines || a.file.localeCompare(b.file))
    .slice(0, size);
}

function topRowsByFilter(
  rows: Row[],
  size: number,
  predicate: (row: Row) => boolean
) {
  return topRows(rows.filter(predicate), size);
}

function isApiRouteFile(file: string) {
  return file.startsWith("app/api/") && file.endsWith("/route.ts");
}

function isFrontendSurfaceFile(file: string) {
  if (file.startsWith("app/api/")) return false;
  if (file.startsWith("app/")) return true;
  if (file.startsWith("components/")) return true;
  return false;
}

function section(title: string, rows: Row[]) {
  const lines: string[] = [];
  lines.push(`## ${title}`);
  lines.push("");
  lines.push("| Lines | File |");
  lines.push("|---:|---|");
  for (const row of rows) {
    lines.push(`| ${row.lines} | \`${row.file}\` |`);
  }
  lines.push("");
  return lines.join("\n");
}

function main() {
  const files = listFiles(REPO_ROOT)
    .map((filePath) => ({
      abs: filePath,
      rel: toRel(filePath),
    }))
    .filter((item) => shouldInclude(item.rel));

  const runtimeRows: Row[] = [];
  const scriptRows: Row[] = [];

  for (const item of files) {
    const lines = countLines(item.abs);
    if (item.rel.startsWith("scripts/")) {
      scriptRows.push({ file: item.rel, lines });
      continue;
    }
    runtimeRows.push({ file: item.rel, lines });
  }

  const topRuntime = topRows(runtimeRows, 25);
  const topApiRoutes = topRowsByFilter(runtimeRows, 20, (row) =>
    isApiRouteFile(row.file)
  );
  const topFrontendSurfaces = topRowsByFilter(runtimeRows, 20, (row) =>
    isFrontendSurfaceFile(row.file)
  );
  const topScripts = topRows(scriptRows, 15);

  const doc: string[] = [];
  doc.push("# Refactor Hotspots");
  doc.push("");
  doc.push("Auto-generated by `scripts/agent/generate-refactor-report.cts`.");
  doc.push("Run `npm run agent:refactor-report` to refresh this report.");
  doc.push(`Generated at: \`${new Date().toISOString()}\``);
  doc.push("");
  doc.push(section("Runtime Top 25", topRuntime));
  doc.push(section("API Route Top 20", topApiRoutes));
  doc.push(section("Frontend Surface Top 20", topFrontendSurfaces));
  doc.push(section("Scripts Top 15", topScripts));
  doc.push("## Notes");
  doc.push("");
  doc.push("- Refresh companion checks with `npm run audit:hotspots` after major changes.");
  doc.push("- Prefer splitting orchestration-heavy files before pure data/config files.");
  doc.push("- For UI files, extract presentational sections first, then hook logic.");
  doc.push("- Re-run after each major refactor to validate actual reduction.");
  doc.push("");

  fs.writeFileSync(OUTPUT_PATH, doc.join("\n"), "utf8");
  console.log(`Wrote hotspot report: ${toRel(OUTPUT_PATH)}`);
}

main();
