const fs = require("node:fs") as typeof import("node:fs");
const pathUtil = require("node:path") as typeof import("node:path");
const {
  listFilesRecursively,
  toPosixRelative,
} = require("../lib/code-file-scan.cts") as {
  listFilesRecursively: (
    rootDir: string,
    options?: {
      excludeDirs?: string[] | Set<string>;
      includeExtensions?: string[] | Set<string>;
      ignoreDotEntries?: boolean;
    }
  ) => string[];
  toPosixRelative: (rootDir: string, filePath: string) => string;
};
const { scanFunctionHotspots } = require("../lib/function-hotspot-scan.cts") as {
  scanFunctionHotspots: (
    source: string,
    filePath?: string,
    minLines?: number
  ) => Array<{
    name: string;
    kind: string;
    startLine: number;
    endLine: number;
    lines: number;
  }>;
};

type HotspotRow = {
  file: string;
  name: string;
  kind: string;
  startLine: number;
  lines: number;
};

const REPO_ROOT = process.cwd();
const OUTPUT_PATH = pathUtil.join(REPO_ROOT, "FUNCTION_HOTSPOTS.md");
const MIN_LINES = 30;

function shouldInclude(rel: string) {
  if (rel.startsWith("docs/")) return false;
  if (rel.startsWith("prisma/migrations/")) return false;
  if (rel.startsWith("android/app/build/")) return false;
  if (rel.startsWith("ios/build/")) return false;
  if (rel.startsWith(".next/")) return false;
  if (rel.endsWith(".md")) return false;
  return (
    rel.endsWith(".ts") ||
    rel.endsWith(".tsx") ||
    rel.endsWith(".js") ||
    rel.endsWith(".jsx")
  );
}

function topRows(rows: HotspotRow[], size: number) {
  return [...rows]
    .sort((a, b) => {
      if (b.lines !== a.lines) return b.lines - a.lines;
      if (a.file !== b.file) return a.file.localeCompare(b.file);
      return a.startLine - b.startLine;
    })
    .slice(0, size);
}

function section(title: string, rows: HotspotRow[]) {
  const lines: string[] = [];
  lines.push(`## ${title}`);
  lines.push("");
  lines.push("| Lines | Kind | Function | Location |");
  lines.push("|---:|---|---|---|");
  for (const row of rows) {
    lines.push(
      `| ${row.lines} | \`${row.kind}\` | \`${row.name}\` | \`${row.file}:${row.startLine}\` |`
    );
  }
  lines.push("");
  return lines.join("\n");
}

function main() {
  const files = listFilesRecursively(REPO_ROOT, {
    excludeDirs: [".git", "node_modules", ".next"],
    ignoreDotEntries: true,
    includeExtensions: [".ts", ".tsx", ".js", ".jsx"],
  })
    .map((absPath) => ({
      abs: absPath,
      rel: toPosixRelative(REPO_ROOT, absPath),
    }))
    .filter((item) => shouldInclude(item.rel));

  const runtimeRows: HotspotRow[] = [];
  const scriptRows: HotspotRow[] = [];

  for (const file of files) {
    const source = fs.readFileSync(file.abs, "utf8");
    const hotspots = scanFunctionHotspots(source, file.rel, MIN_LINES);
    if (hotspots.length === 0) continue;

    for (const hotspot of hotspots) {
      const row: HotspotRow = {
        file: file.rel,
        name: hotspot.name,
        kind: hotspot.kind,
        startLine: hotspot.startLine,
        lines: hotspot.lines,
      };
      if (file.rel.startsWith("scripts/")) {
        scriptRows.push(row);
      } else {
        runtimeRows.push(row);
      }
    }
  }

  const topRuntime = topRows(runtimeRows, 50);
  const topScripts = topRows(scriptRows, 30);

  const doc: string[] = [];
  doc.push("# Function Hotspots");
  doc.push("");
  doc.push("Auto-generated by `scripts/agent/generate-function-hotspots.cts`.");
  doc.push("Run `npm run agent:function-hotspots` to refresh this report.");
  doc.push("");
  doc.push(
    `Only function-like blocks with at least ${MIN_LINES} lines are included.`
  );
  doc.push("");
  doc.push(section("Runtime Top 50", topRuntime));
  doc.push(section("Scripts Top 30", topScripts));
  doc.push("## Notes");
  doc.push("");
  doc.push("- Prioritize refactors where both file-level and function-level hotspots overlap.");
  doc.push(
    "- For React pages/clients, split UI sections first and then split mutation/network handlers."
  );
  doc.push(
    "- For scripts, extract pure helpers before touching orchestration flow to keep behavior stable."
  );
  doc.push("");

  const nextContent = doc.join("\n");
  const currentContent = fs.existsSync(OUTPUT_PATH)
    ? fs.readFileSync(OUTPUT_PATH, "utf8")
    : null;

  if (currentContent !== nextContent) {
    fs.writeFileSync(OUTPUT_PATH, nextContent, "utf8");
    console.log(
      `Wrote function hotspot report: ${toPosixRelative(REPO_ROOT, OUTPUT_PATH)}`
    );
  } else {
    console.log(
      `Function hotspot report unchanged: ${toPosixRelative(REPO_ROOT, OUTPUT_PATH)}`
    );
  }
}

main();
