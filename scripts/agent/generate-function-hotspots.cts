const fs = require("node:fs") as typeof import("node:fs");
const pathUtil = require("node:path") as typeof import("node:path");
const { listHotspotCodeFiles } = require("../lib/hotspot-code-files.cts") as {
  listHotspotCodeFiles: (
    rootDir: string
  ) => Array<{
    abs: string;
    rel: string;
  }>;
};
const {
  isScriptFile,
} = require("../lib/hotspot-paths.cts") as {
  isScriptFile: (file: string) => boolean;
};
const { scanFunctionHotspots } = require("../lib/function-hotspot-scan.cts") as {
  scanFunctionHotspots: (
    source: string,
    filePath?: string,
    minLines?: number
  ) => Array<{
    name: string;
    kind: string;
    startLine: number;
    endLine: number;
    lines: number;
  }>;
};
const { writeIfChanged } = require("../lib/write-if-changed.cts") as {
  writeIfChanged: (options: {
    outputPath: string;
    content: string;
    rootDir?: string;
    encoding?: BufferEncoding;
  }) => {
    changed: boolean;
    outputPath: string;
    relativePath: string;
  };
};

type HotspotRow = {
  file: string;
  name: string;
  kind: string;
  startLine: number;
  lines: number;
};

const REPO_ROOT = process.cwd();
const OUTPUT_PATH = pathUtil.join(REPO_ROOT, "FUNCTION_HOTSPOTS.md");
const MIN_LINES = 30;

function topRows(rows: HotspotRow[], size: number) {
  return [...rows]
    .sort((a, b) => {
      if (b.lines !== a.lines) return b.lines - a.lines;
      if (a.file !== b.file) return a.file.localeCompare(b.file);
      return a.startLine - b.startLine;
    })
    .slice(0, size);
}

function section(title: string, rows: HotspotRow[]) {
  const lines: string[] = [];
  lines.push(`## ${title}`);
  lines.push("");
  lines.push("| Lines | Kind | Function | Location |");
  lines.push("|---:|---|---|---|");
  for (const row of rows) {
    lines.push(
      `| ${row.lines} | \`${row.kind}\` | \`${row.name}\` | \`${row.file}:${row.startLine}\` |`
    );
  }
  lines.push("");
  return lines.join("\n");
}

function main() {
  const files = listHotspotCodeFiles(REPO_ROOT);

  const runtimeRows: HotspotRow[] = [];
  const scriptRows: HotspotRow[] = [];

  for (const file of files) {
    const source = fs.readFileSync(file.abs, "utf8");
    const hotspots = scanFunctionHotspots(source, file.rel, MIN_LINES);
    if (hotspots.length === 0) continue;

    for (const hotspot of hotspots) {
      const row: HotspotRow = {
        file: file.rel,
        name: hotspot.name,
        kind: hotspot.kind,
        startLine: hotspot.startLine,
        lines: hotspot.lines,
      };
      if (isScriptFile(file.rel)) {
        scriptRows.push(row);
      } else {
        runtimeRows.push(row);
      }
    }
  }

  const topRuntime = topRows(runtimeRows, 50);
  const topScripts = topRows(scriptRows, 30);

  const doc: string[] = [];
  doc.push("# Function Hotspots");
  doc.push("");
  doc.push("Auto-generated by `scripts/agent/generate-function-hotspots.cts`.");
  doc.push("Run `npm run agent:function-hotspots` to refresh this report.");
  doc.push("");
  doc.push(
    `Only function-like blocks with at least ${MIN_LINES} lines are included.`
  );
  doc.push("");
  doc.push(section("Runtime Top 50", topRuntime));
  doc.push(section("Scripts Top 30", topScripts));
  doc.push("## Notes");
  doc.push("");
  doc.push("- Prioritize refactors where both file-level and function-level hotspots overlap.");
  doc.push(
    "- For React pages/clients, split UI sections first and then split mutation/network handlers."
  );
  doc.push(
    "- For scripts, extract pure helpers before touching orchestration flow to keep behavior stable."
  );
  doc.push("");

  const nextContent = doc.join("\n");
  const writeResult = writeIfChanged({
    outputPath: OUTPUT_PATH,
    content: nextContent,
    rootDir: REPO_ROOT,
  });
  if (writeResult.changed) {
    console.log(`Wrote function hotspot report: ${writeResult.relativePath}`);
  } else {
    console.log(`Function hotspot report unchanged: ${writeResult.relativePath}`);
  }
}

main();
