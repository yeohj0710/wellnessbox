const fs = require("node:fs") as typeof import("node:fs");
const pathUtil = require("node:path") as typeof import("node:path");
const { writeIfChanged } = require("../lib/write-if-changed.cts") as {
  writeIfChanged: (options: {
    outputPath: string;
    content: string;
    rootDir?: string;
    encoding?: BufferEncoding;
  }) => {
    changed: boolean;
    outputPath: string;
    relativePath: string;
  };
};

type FileHotspotRow = {
  lines: number;
  file: string;
};

type FunctionHotspotRow = {
  lines: number;
  name: string;
  location: string;
};

type GuardSummary = {
  totalRoutes: string;
  guardedRoutes: string;
  expectedSessionRoutes: string;
  unexpectedReviewNeeded: string;
  missingMethodExports: string;
  publicOrInternalCandidates: string;
  guardPolicyViolations: string;
};

const REPO_ROOT = process.cwd();
const REFACTOR_REPORT_PATH = pathUtil.join(REPO_ROOT, "REFACTOR_HOTSPOTS.md");
const FUNCTION_REPORT_PATH = pathUtil.join(REPO_ROOT, "FUNCTION_HOTSPOTS.md");
const GUARD_REPORT_PATH = pathUtil.join(REPO_ROOT, "API_GUARD_MAP.md");
const OUTPUT_PATH = pathUtil.join(REPO_ROOT, "AGENT_SESSION_PRIMER.md");

function readUtf8(filePath: string) {
  if (!fs.existsSync(filePath)) {
    throw new Error(`Required report missing: ${filePath}`);
  }
  return fs.readFileSync(filePath, "utf8");
}

function extractSection(source: string, heading: string) {
  const marker = `## ${heading}`;
  const start = source.indexOf(marker);
  if (start < 0) return "";

  const afterStart = source.slice(start + marker.length);
  const nextHeadingOffset = afterStart.indexOf("\n## ");
  return nextHeadingOffset >= 0
    ? afterStart.slice(0, nextHeadingOffset)
    : afterStart;
}

function parseMarkdownTableRows(section: string) {
  const rows: string[][] = [];
  for (const rawLine of section.split(/\r?\n/)) {
    const line = rawLine.trim();
    if (!line.startsWith("|")) continue;
    if (line.includes("|---")) continue;
    const cells = line
      .split("|")
      .slice(1, -1)
      .map((cell) => cell.trim());
    if (cells.length === 0) continue;
    if (cells.every((cell) => cell.length === 0)) continue;
    rows.push(cells);
  }
  return rows;
}

function stripInlineCode(value: string) {
  return value.replace(/`/g, "");
}

function parseFileHotspots(source: string, heading: string, limit: number) {
  const section = extractSection(source, heading);
  const tableRows = parseMarkdownTableRows(section);
  const parsed: FileHotspotRow[] = [];
  for (const row of tableRows) {
    if (row.length < 2) continue;
    if (!/\d/.test(row[0])) continue;
    const lines = Number(row[0].replace(/[^\d]/g, ""));
    const file = stripInlineCode(row[1]);
    if (!Number.isFinite(lines) || !file) continue;
    parsed.push({ lines, file });
    if (parsed.length >= limit) break;
  }
  return parsed;
}

function parseFunctionHotspots(source: string, heading: string, limit: number) {
  const section = extractSection(source, heading);
  const tableRows = parseMarkdownTableRows(section);
  const parsed: FunctionHotspotRow[] = [];
  for (const row of tableRows) {
    if (row.length < 4) continue;
    if (!/\d/.test(row[0])) continue;
    const lines = Number(row[0].replace(/[^\d]/g, ""));
    const name = stripInlineCode(row[2]);
    const location = stripInlineCode(row[3]);
    if (!Number.isFinite(lines) || !name || !location) continue;
    parsed.push({ lines, name, location });
    if (parsed.length >= limit) break;
  }
  return parsed;
}

function parseGuardSummary(source: string): GuardSummary {
  const fallback = "N/A";
  const capture = (label: string) => {
    const pattern = new RegExp(`- ${label}: \\*\\*([^*]+)\\*\\*`);
    const match = source.match(pattern);
    return match?.[1]?.trim() || fallback;
  };

  return {
    totalRoutes: capture("Total routes"),
    guardedRoutes: capture("Guarded routes"),
    expectedSessionRoutes: capture("Expected session-managed routes"),
    unexpectedReviewNeeded: capture("Unexpected review needed"),
    missingMethodExports: capture("Missing method exports"),
    publicOrInternalCandidates: capture("Public/Internal candidate routes"),
    guardPolicyViolations: capture("Guard policy violations"),
  };
}

function buildMarkdown(input: {
  runtimeFileHotspots: FileHotspotRow[];
  runtimeFunctionHotspots: FunctionHotspotRow[];
  guardSummary: GuardSummary;
}) {
  const lines: string[] = [];
  lines.push("# Agent Session Primer");
  lines.push("");
  lines.push("Auto-generated by `scripts/agent/generate-session-primer.cts`.");
  lines.push(
    "Run `npm run agent:context-refresh` (or `npm run agent:session-primer`) to refresh."
  );
  lines.push("");
  lines.push("## Fast Start");
  lines.push("");
  lines.push("1. `npm run audit:encoding`");
  lines.push("2. `npm run audit:hotspots`");
  lines.push("3. `npm run agent:guard-map`");
  lines.push("4. `npm run lint`");
  lines.push("5. `npm run build`");
  lines.push("");
  lines.push("## Guard Snapshot");
  lines.push("");
  lines.push(`- Total routes: **${input.guardSummary.totalRoutes}**`);
  lines.push(`- Guarded routes: **${input.guardSummary.guardedRoutes}**`);
  lines.push(
    `- Expected session-managed routes: **${input.guardSummary.expectedSessionRoutes}**`
  );
  lines.push(
    `- Unexpected review needed: **${input.guardSummary.unexpectedReviewNeeded}**`
  );
  lines.push(
    `- Missing method exports: **${input.guardSummary.missingMethodExports}**`
  );
  lines.push(
    `- Public/Internal candidate routes: **${input.guardSummary.publicOrInternalCandidates}**`
  );
  lines.push(
    `- Guard policy violations: **${input.guardSummary.guardPolicyViolations}**`
  );
  lines.push("");
  lines.push("## Runtime File Hotspots (Top 12)");
  lines.push("");
  for (const row of input.runtimeFileHotspots) {
    lines.push(`- ${String(row.lines).padStart(4, " ")} lines: \`${row.file}\``);
  }
  lines.push("");
  lines.push("## Runtime Function Hotspots (Top 12)");
  lines.push("");
  for (const row of input.runtimeFunctionHotspots) {
    lines.push(
      `- ${String(row.lines).padStart(4, " ")} lines: \`${row.name}\` (\`${row.location}\`)`
    );
  }
  lines.push("");
  lines.push("## Critical Edit Invariants");
  lines.push("");
  lines.push(
    "- Order integrity: keep stock decrement only inside `lib/order/mutations.ts:createOrder` transaction."
  );
  lines.push(
    "- Route ownership/auth: use guards from `lib/server/route-auth.ts` only."
  );
  lines.push("- Prisma: keep singleton pattern in `lib/db.ts`.");
  lines.push(
    "- Admin gate: keep `app/api/verify-password/route.ts`, `lib/admin-token.ts`, and `middleware.ts` aligned."
  );
  lines.push("");
  return lines.join("\n");
}

function main() {
  const refactorReport = readUtf8(REFACTOR_REPORT_PATH);
  const functionReport = readUtf8(FUNCTION_REPORT_PATH);
  const guardReport = readUtf8(GUARD_REPORT_PATH);

  const runtimeFileHotspots = parseFileHotspots(refactorReport, "Runtime Top 25", 12);
  const runtimeFunctionHotspots = parseFunctionHotspots(
    functionReport,
    "Runtime Top 50",
    12
  );
  const guardSummary = parseGuardSummary(guardReport);

  const markdown = buildMarkdown({
    runtimeFileHotspots,
    runtimeFunctionHotspots,
    guardSummary,
  });

  const writeResult = writeIfChanged({
    outputPath: OUTPUT_PATH,
    content: markdown,
    rootDir: REPO_ROOT,
  });
  if (writeResult.changed) {
    console.log(`Wrote session primer: ${writeResult.relativePath}`);
  } else {
    console.log(`Session primer unchanged: ${writeResult.relativePath}`);
  }
}

main();
